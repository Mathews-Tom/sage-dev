import { writeFile, mkdir } from 'fs/promises';
import { dirname, join } from 'path';
import { pathToFileURL } from 'url';
import { RepositoryPatterns, RepositoryPatternsSchema } from '../schemas/repository-patterns.js';

const PATTERNS_FILE_NAME = 'repository-patterns.ts';

export async function savePatterns(
  patterns: RepositoryPatterns,
  outputDir: string
): Promise<string> {
  const validated = RepositoryPatternsSchema.parse(patterns);
  const filePath = join(outputDir, PATTERNS_FILE_NAME);

  await mkdir(dirname(filePath), { recursive: true });

  const content = generateTypeScriptFile(validated);
  await writeFile(filePath, content, 'utf-8');

  return filePath;
}

export async function loadPatterns(patternsDir: string): Promise<RepositoryPatterns | null> {
  const filePath = join(patternsDir, PATTERNS_FILE_NAME);
  const fileUrl = pathToFileURL(filePath).href;

  try {
    const module = await import(fileUrl);
    const patterns = module.REPOSITORY_PATTERNS;

    if (!patterns) {
      throw new Error('REPOSITORY_PATTERNS export not found');
    }

    return RepositoryPatternsSchema.parse(patterns);
  } catch (error) {
    const errCode = (error as NodeJS.ErrnoException).code;
    const errMessage = (error as Error).message || '';
    if (
      errCode === 'ERR_MODULE_NOT_FOUND' ||
      errMessage.includes('Does the file exist') ||
      errMessage.includes('Cannot find module')
    ) {
      return null;
    }
    throw error;
  }
}

function generateTypeScriptFile(patterns: RepositoryPatterns): string {
  const serialized = JSON.stringify(patterns, null, 2);

  const content = `// Auto-generated by sage-context-optimizer
// Do not edit manually - regenerate with /sage.init

import type { RepositoryPatterns } from '@sage-dev/context-optimizer/schemas/repository-patterns';

export const REPOSITORY_PATTERNS: RepositoryPatterns = ${serialized};

export default REPOSITORY_PATTERNS;
`;

  return content;
}

export function formatPatternsForDisplay(patterns: RepositoryPatterns): string {
  const lines: string[] = [];

  lines.push(`Repository: ${patterns.metadata.name}`);
  lines.push(`Path: ${patterns.metadata.path}`);
  lines.push(`Primary Language: ${patterns.primaryLanguage}`);
  lines.push(`Overall Confidence: ${(patterns.overallConfidence * 100).toFixed(1)}%`);
  lines.push(`Files Analyzed: ${patterns.metadata.analyzedFiles} / ${patterns.metadata.totalFiles}`);
  lines.push(`Extracted At: ${patterns.metadata.extractedAt}`);
  lines.push('');

  if (patterns.languages.python) {
    const py = patterns.languages.python;
    lines.push('Python Patterns:');
    lines.push(`  Functions: ${py.naming.functions.pattern} (${py.naming.functions.percentage.toFixed(1)}% consistent)`);
    lines.push(`  Classes: ${py.naming.classes.pattern} (${py.naming.classes.percentage.toFixed(1)}% consistent)`);
    lines.push(`  Type Hints: ${py.types.typeHintCoverage.toFixed(1)}% coverage`);
    lines.push(`  Union Syntax: ${py.types.unionSyntax}`);
    lines.push(`  Test Framework: ${py.testing.framework}`);
    lines.push(`  Confidence: ${(py.confidence.overall * 100).toFixed(1)}%`);
    lines.push('');
  }

  if (patterns.languages.typescript) {
    const ts = patterns.languages.typescript;
    lines.push('TypeScript Patterns:');
    lines.push(`  Functions: ${ts.naming.functions.pattern} (${ts.naming.functions.percentage.toFixed(1)}% consistent)`);
    lines.push(`  Classes: ${ts.naming.classes.pattern} (${ts.naming.classes.percentage.toFixed(1)}% consistent)`);
    lines.push(`  Interfaces: ${ts.naming.interfaces.pattern} (${ts.naming.interfaces.percentage.toFixed(1)}% consistent)`);
    lines.push(`  Module System: ${ts.architecture.moduleSystem}`);
    lines.push(`  Test Framework: ${ts.testing.framework}`);
    lines.push(`  Confidence: ${(ts.confidence.overall * 100).toFixed(1)}%`);
    lines.push('');
  }

  return lines.join('\n');
}
